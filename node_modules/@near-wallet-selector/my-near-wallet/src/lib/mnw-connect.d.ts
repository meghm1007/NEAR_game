import type { Action, FinalExecutionOutcome, Network, SignedMessage, SignMessageParams, Transaction } from "@near-wallet-selector/core";
import { transactions } from "near-api-js";
import type { KeyPairString, PublicKey } from "near-api-js/lib/utils";
import type { JsonRpcProvider } from "near-api-js/lib/providers";
interface WalletMessage {
    status: "success" | "failure" | "pending";
    transactionHashes?: string;
    error?: string;
    [key: string]: unknown;
    signedRequest?: SignedMessage;
    errorMessage?: string;
    errorCode?: string;
}
interface FunctionCallKey {
    privateKey: KeyPairString;
    contractId: string;
    methods: Array<string>;
}
export declare class MyNearWalletConnector {
    walletUrl: string;
    signedAccountId: string;
    functionCallKey: FunctionCallKey | null;
    provider: JsonRpcProvider;
    network: Network;
    constructor(walletUrl: string, network: Network);
    getAccountId(): string;
    getPublicKey(): PublicKey | undefined;
    isSignedIn(): boolean;
    signOut(): void;
    requestSignIn({ contractId, methodNames, }: {
        contractId: string;
        methodNames?: Array<string>;
    }): Promise<Array<{
        accountId: string;
        publicKey: string;
    }>>;
    requestSignInUrl({ contractId, methodNames, }: {
        contractId: string;
        methodNames?: Array<string>;
    }): Promise<string>;
    signMessage({ message, nonce, recipient, callbackUrl, state, }: SignMessageParams): Promise<{
        accountId: string;
        publicKey: string;
        signature: string;
    }>;
    signAndSendTransactions(transactionsWS: Array<Transaction>): Promise<Array<FinalExecutionOutcome>>;
    signAndSendTransaction({ receiverId, actions, }: {
        receiverId: string;
        actions: Array<Action>;
    }): Promise<FinalExecutionOutcome>;
    completeTransaction({ receiverId, actions, }: {
        receiverId: string;
        actions: Array<Action>;
    }): Promise<transactions.Transaction>;
    signAndSendTransactionsMNW(txs: Array<transactions.Transaction>): Promise<Array<FinalExecutionOutcome>>;
    storedKeyCanSign(receiverId: string, actions: Array<Action>): boolean;
    signUsingKeyPair({ receiverId, actions, }: {
        receiverId: string;
        actions: Array<Action>;
    }): Promise<FinalExecutionOutcome>;
    requestSignTransactionsUrl(txs: Array<transactions.Transaction>): string;
    handlePopupTransaction<T>(url: string, callback: (result: WalletMessage) => T): Promise<T>;
    private setupMessageHandler;
}
export {};
